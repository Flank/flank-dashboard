# CI Integrations GitHub Actions integration.

> Summary of the proposed change

Describe the integration mechanism of the CI Integrations component to the GitHub Actions to automatically push the build data.

# References

> Link to supporting documentation, GitHub tickets, etc.

- [CI integrations](metrics/ci_integrations/docs/01_ci_integration_module_architecture.md)

# Motivation

> What problem is this project solving?

This document describes the configuration process of the CI Integrations to automatically synchronize the GitHub Actions build data to the Metrics Web application.

# Goals

> Identify success metrics and measurable goals.

This document aims the following goals: 

- Explain the CI Integrations configuration process.
- Explain the mechanism of automation build imports using the GitHub Actions and CI Integrations tool.

# Non-Goals

> Identify what's not in scope.

This document does not describe the configuration of building or publishing jobs.

# CI Integrations tool configuration

> Explain and diagram the technical design
>
> Identify risks and edge cases

To be able to synchronize build data using the CI Integrations tool we should create `YAML` configuration files for each project that will be used by the CI Integrations tool to sync the build data with the Metrics Web application. Assume we have an `Awesome Project` and an `awesome_actions.yml` workflow file with `Awesome Project Actions` job used to run tests of the `Awesome Project`. If so, let's create a sample configuration file for this project. The configuration should consist of the following parts: 

- [Source configuration](#Source-configuration)
- [Destination configuration](#Destination-configuration) 

Let's consider this parts separately: 

## Source configuration

The `source` part describes the source of the build data - GitHub Actions in our case. Let's review a `source` configuration for the `Awesome Project`: 

```yaml
source:
  github_actions:
    workflow_identifier: awesome_actions.yml
    repository_name: awesome_repository
    repository_owner: awesome
    access_token: $GITHUB_TOKEN
    job_name: Awesome Project Actions
    coverage_artifact_name: coverage_report
```

So, the GitHub Actions configuration consists of the following properties: 

| Property name           | Type           | Description  |
| ----------------------- |:--------------:| ----------------------------------|
| workflow_identifier     | Public         | An identifier of the building workflow to export data from. The workflow identifier is a workflow file name. |
| repository_name         | Public         | A name of the repository that contains the specified workflow. |
| repository_owner        | Public         | A username or an organization name that owns the repository. |
| access_token            | Secret         | A GitHub API access token. Since we are using the GitHub actions to run the synchronization, we can use the default token from secrets `${{ secrets.GITHUB_TOKEN }}`, but, you can create separate personal access token using this [guide](https://docs.github.com/en/free-pro-team@latest/github/authenticating-to-github/creating-a-personal-access-token). Your token should have the `repo` scope to be able to load the data from the GitHub Actions API.|
| job_name                | Public         | A name of the job inside of the workflow with the provided `workflow_identifier`. The build data of this job will be exported to the Metrics Web Application.|
| coverage_artifact_name  | Public         | A name of the coverage artifact exported from the building workflow with the specified `workflow_identifier`. Notice, that the coverage artifact should be in the [CI Integrations format](https://github.com/platform-platform/monorepo/blob/master/metrics/ci_integrations/docs/01_ci_integration_module_architecture.md#coverage-report-format). You can use the [Coverage Converter](https://github.com/platform-platform/monorepo/releases/tag/coverage-converter-snapshot) tool to convert the report generated by your coverage tool to the CI Integrations readable format. |


## Destination configuration

Since we want to export data to the Metrics Web Application, we should specify the destination `firestore` configuration. Let's consider an example of the `firestore` configuration: 

```yaml
destination:
  firestore:
    firebase_project_id: project_id
    firebase_user_email: $FIREBASE_USER_EMAIL
    firebase_user_pass: $FIREBASE_USER_PASSWORD
    firebase_public_api_key: $FIREBASE_PUBLIC_API_KEY
    metrics_project_id: awesome_project
```

So, the `firestore` configuration should contain the following keys: 

| Property Name            | Type   | Description  |
| ------------------------ |:------:| -------------|
| firebase_project_id      | Public | A firebase project identifier where to export the data. |
| firebase_user_email      | Secret | A firebase user email used to log in to the Metrics Web Application. |
| firebase_user_pass       | Secret | A firebase user password used to log in to the Metrics Web Application. |
| firebase_public_api_key  | Secret | A public API key that could be created using the Google Cloud Platform in the [API & Services credentials](https://console.cloud.google.com/apis/credentials?project=metrics-d9c67) section. This key should have access to the `Identity Toolkit API`. For more information about Firebase API Keys check [this article](https://firebase.google.com/docs/projects/api-keys). |
| metrics_project_id       | Public | A firestore document identifier of the project to import data to. |

__*Please, NOTE*__ that the `Secret` values must be stored as [GitHub Secrets](https://docs.github.com/en/free-pro-team@latest/actions/reference/encrypted-secrets). The configuration file can contain these fields as environment variables. To replace them in the GitHub actions workflow, you can use `gettext` or replace it using the `sed` tool. An example of the step which replaces the environment variables in the configuration file provided below:  

```yaml
      - name: Apply environment variables
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          WEB_APP_USER_EMAIL: ${{ secrets.WEB_APP_USER_EMAIL }}
          WEB_APP_USER_PASSWORD: ${{ secrets.WEB_APP_USER_PASSWORD }}
          CI_INTEGRATIONS_FIREBASE_API_KEY: ${{ secrets.CI_INTEGRATIONS_FIREBASE_API_KEY }}
        run: eval "echo \"$(sed 's/"/\\"/g' awesome_config.yml)\"" >> integration.yml
```

As you can see, you should specify all the environment variables used in the configuration file in the `env` section of the step. To get access to the `GitHub Secrets` in the `GitHub Actions`, you can use the following notation `${{ secrets.YOUR_SECRET_NAME }}`, where the `YOUR_SECRET_NAME` is a name of the secret configured in your GitHub Repository. Then you should specify the command used to replace the environment variables in the file. You can use the command from the example that does not require any additional packages installed for macOS and Linux platforms but can be less readable, or use the `gettext` command-line tool to make it more human-readable. The example of using the `gettext` provided below: 

`envsubst < awesome_config.yml > integration.yml`

The `gettext` installation process described in this article: [Install Gettext](https://www.drupal.org/docs/8/modules/potion/how-to-install-setup-gettext).

# GitHub Actions configuration

Once we've finished creating the configuration file, we should configure the GitHub Actions, which will export the build data to the Metrics Web application. Let's review a sequence diagram that will show the main actions and explain the relationships between them:

![GitHub Actions Sequence Diagram](http://www.plantuml.com/plantuml/proxy?cache=no&fmt=svg&src=https://raw.githubusercontent.com/platform-platform/monorepo/github_actions_integrations_doc/docs/diagrams/github_actions_sequence_diagram.puml)

As we see in the diagram above, we should configure the following actions for synchronization: 

- [`Notify about the finishing awesome project build`](#Notify-about-the-finishing-awesome-project-build) - the job needed to notify the `Metrics Integration Actions` that some project build was started.
- [`Metrics Integration Actions`](#Metrics-Integration-Actions) - the workflow needed to export the data to the Metrics Web application using the CI Integrations component.

Let's consider each action in more detail.

## Notify about the finishing awesome project build

The `Notify about the finishing awesome project build` step notifies the `Metrics Integration Actions` about some project's build finishing. This job should emit a repository dispatch event containing `client_payload` with the `building_awesome_project` boolean field in the `client_payload`. To send the repository dispatch event, we are using the [Repository Dispatch](https://github.com/marketplace/actions/repository-dispatch) action.

This job is required because the `CI Integrations` tool only synchronizes the build data, and we should ensure that the build is finished before running the synchronization. It is needed because we should be sure that the `CI Integrations` tool will import the real build status and build duration to the Metrics Application.  Also, the `CI Integrations` tool collects the coverage information for the build assets, and the GitHub Actions exposes the assets only when the workflow finishes.

Also, to reduce the amount of time taken for the `Metrics Integration Actions` workflow, we should run the `Notify about the finishing awesome project build` job after all jobs in the project building workflow. To do so, this job should depend on all jobs from the current workflow, defining the [needs](https://docs.github.com/en/free-pro-team@latest/actions/reference/workflow-syntax-for-github-actions#jobsjob_idneeds) key in the configuration file. Moreover, the `Notify about the finishing awesome project build` job should run even if any of the other jobs canceled/failed, so it should include the `if: "always()"` option.

Let's consider the example of the `Notify about the finishing awesome project build` job for `Awesome project` in our repository: 

Assume we have a workflow containing the following jobs: 

- `Run tests` with `run_awesome_tests` identifier.
- `Build and publish` with `build_and_publish_app` identifier.


So, the `Notify about the finishing awesome project build` for this project will look like this: 

```yml
  notify-actions:
    name: Notify about building the Awesome project
    runs-on: macos-latest
    needs: [ run_awesome_tests, build_and_publish_app ]
    if: "always()"
    steps:
      - name: Notify about building the Awesome project
        uses: peter-evans/repository-dispatch@v1
        with:
          token: ${{ secrets.ACTIONS_TOKEN }}
          repository: platform-platform/monorepo
          event-type: building_project
          client-payload: '{"building_awesome_project": "true"}'
```

As you can see above, the `Notify about building the Awesome project` uses some `ACTIONS_TOKEN` secret environment variable. This secret is a [GitHub personal access token](https://docs.github.com/en/free-pro-team@latest/github/authenticating-to-github/creating-a-personal-access-token) configured to have access to all public and private repositories of the user.


## Metrics Integration Actions

A `Metrics Integration Actions` is a workflow used to export the build data to the Metrics Web application. This workflow triggers on repository dispatch event with `building_project` type sent by `Notify about the finishing awesome project build` job. The `building_project` repository dispatch event, in its turn, should contain the information about which project build started as a `client_payload` JSON. 

Let's consider the sample `Metrics Integration Actions` workflow file: 

```yaml
name: Metrics Integration Actions

on:
  repository_dispatch:
    types: [ building_project ]

jobs:
  awesome_project_sync:
    name: Awesome Project build data sync
    runs-on: macos-latest
    if: github.event.client_payload.building_awesome_project == 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@v2
        with:
          fetch-depth: 1
          ref: ${{ github.ref }}
      - name: Download Ci integrations
        run: |
          curl -o ci_integrations -k https://github.com/platform-platform/monorepo/releases/download/ci_integrations-snapshot/ci_integrations_macos -L
          chmod a+x ci_integrations
      - name: Wait For Awesome Project check finished
        uses: fountainhead/action-wait-for-check@v1.0.0
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          checkName: Notify about building the Awesome Project
          ref: ${{ github.sha }}
          timeoutSeconds: 3600
      - name: Apply environment variables
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          WEB_APP_USER_EMAIL: ${{ secrets.WEB_APP_USER_EMAIL }}
          WEB_APP_USER_PASSWORD: ${{ secrets.WEB_APP_USER_PASSWORD }}
          CI_INTEGRATIONS_FIREBASE_API_KEY: ${{ secrets.CI_INTEGRATIONS_FIREBASE_API_KEY }}
        run: eval "echo \"$(sed 's/"/\\"/g' awesome_config.yml)\"" >> integration.yml
        working-directory: awesome_project/
      - name: Awesome Project build data sync
        run: ./ci_integrations sync --config-file .metrics/integration.yml
```

So, once the `Metrics Integration Actions` workflow receives the `building_project` repository dispatch event, it gets the project that is currently building from the `client_payload` and starts the synchronization job that corresponds to the building project to export the building data. The synchronization job, in its turn, checkouts the repository, waits until the project's building job gets finished, downloads the `CI Integrations` tool, and runs the synchronization process.

__*Please, NOTE*__  that since we are using the [Wait For Check](https://github.com/marketplace/actions/wait-for-check) action that allows us to wait until the job gets finished, we should wait unlit the last workflow job gets finished. Usually, this job is a `Notify about the finishing awesome project build`. It is needed to be sure that the project's building workflow is finished and we can get the building artifacts from this workflow if there any.


# Dependencies

> What is the project blocked on?

This project has no dependencies.

> What will be impacted by the project?

The GitHub actions configuration process will be impacted.

# Testing

> How will the project be tested?

This project will be tested manually. 

# Alternatives Considered

> Summarize alternative designs (pros & cons)

No alternatives considered.

# Results

> What was the outcome of the project?

The configuration process was described with examples provided.
