# Import code coverage from supported CI servers
> Summary of the proposed change

Fetch code coverage data using the CI artifact API.

# References
> Link to supporting documentation, GitHub tickets, etc.

- [Bitrise](https://devcenter.bitrise.io/).
- [Buildkite](https://buildkite.com/docs/tutorials/getting-started).
- [CircleCI](https://circleci.com/docs/).
- [Jenkins](https://jenkins.io/doc/).

# Motivation
> What problem is this project solving?

Automatically collect code coverage metrics from various CI providers and build jobs.

# Goals
> Identify success metrics and measurable goals.

* CI can export coverage metric as an artifact.
* Exported artifacts are accessible via the CI's API.

# Non-Goals
> Identify what's not in scope.

Implementing code coverage artifact creation is out of scope because it depends on CI, job, code coverage tool and even programming language.

# Design
> Explain and diagram the technical design

`CI` → `Artifacts storage` → `API` → `Metrics app`

> Identify risks and edge cases

* The approach is sensitive to breaks/changes of CI artifacts storage or API server - the importing flow may require changes as well. 

# API
> What will the proposed API look like?

Add a build step to export coverage metric as an artifact - so, later on, it is accessible via API from artifacts related to the build.

# Bitrise

## Deploy artifacts
Artifacts are deployed into bitrise.io with the help of the **Deploy to Bitrise.io** Step. Use the following steps to get generated files accessible within build:
1. Generate artifacts during one of the workflow steps.
2. Insert the Deploy to Bitrise.io Step AFTER the Step(s) that generate the artifacts.
3. Change the target directory path in the **Deploy directory or file path** field under the **Config** section of the step if required.
   For example `$BITRISE_SOURCE_DIR/build/` or `$BITRISE_SOURCE_DIR/coverage/`. 

More information [here](https://devcenter.bitrise.io/builds/build-artifacts-online/).

## Create API Access Token
The authorization is required to communicate with Bitrise API. For this purpose, the user can generate a Personal access token.
1. On Bitrise navigate to your [Account settings](https://www.bitrise.io/me/profile) and click on the [Security tab](https://app.bitrise.io/me/profile#/security).
2. Scroll to the **Personal access token (BETA)** section and press the **Generate new** button.
3. Provide a token description (must be unique) and select expiration duration in the popup. **Save & Continue** to proceed.
4. Next popup will contain the token generated. **Make sure to copy your new personal access token. You won’t be able to see it again!**
5. Use a new token in requests by setting `Authorization: <access token>` header.

For more detailed instructions please see [discussion](https://discuss.bitrise.io/t/personal-access-tokens-beta/1383) and [documentation](https://devcenter.bitrise.io/api/authentication/). 

## Retrieve artifacts via API
Bitrise provides several endpoints to work with builds and artifacts. Here is a list of endpoints you can use to import code coverage artifact:
 - **GET** `/apps/{app-slug}/builds` responses with a list of builds. Each build contains the `slug` field which stands for an ID of this build. Select the one you want to load code coverage artifact for and proceed to the next endpoint.
 - **GET** `/apps/{app-slug}/builds/{build-slug}/artifacts` responses with a list of artifacts generated and deployed during the build specified by `build-slug` path parameter. Select the one you need and use its `slug` field within the next endpoint.
 - **GET** `/apps/{app-slug}/builds/{build-slug}/artifacts/{artifact-slug}` responses with an artifact description specified by `artifact-slug` path parameter. The response body contains JSON with the `expiring_download_url` field containing URL for downloading artifact.

The `app-slug` is your app's unique ID generated by Bitrise that can found on the bitrise.io Web UI. 
1. Open the [Dashboard](https://app.bitrise.io/dashboard/builds) on Bitrise - you may be asked to log in first.
2. Click on a project you want to know the ID of from the right-side panel.
3. On the project page, go to the `Code` tab.
4. You can find the `app-slug` right under the `App Slug` section (you can also find it in a current page's URL - for example, `https://app.bitrise.io/app/<app-slug>#/code`).

More information in accessing artifacts you can find in [documentation](https://devcenter.bitrise.io/getting-started/managing-files-on-bitrise/). Bitrise API [specification](https://api-docs.bitrise.io/#/).

# Buildkite

## Deploy artifacts
Artifacts can be uploaded automatically after a pipeline's build step finishes its execution. This requires additional configurations to the build step using either web UI on Builkite or `pipeline.yml` configuration file in your project.
- **Using web UI**:
    1. Under the **Steps** section within pipeline settings, create a new step pressing **Add** button or select an existing step from the list.
    2. On the right side of the step's configuration panel expand the **Automatic Artifact Uploading** option.
    3. Define path pattern to the artifacts you want to upload after the step finishes (multiple paths must be separated by a semicolon). For example, `logs/**/*`, `tmp/**/*.png`, `logs/**/*;tmp/**/*.png` and so on.
- **Using `pipeline.yml`**:
    1. Go to the step you want to configure artifacts uploading for.
    2. Set the `artifact_paths` attribute on your command step with path pattern(s) (see example below).
    ```yaml
    steps:
      - label: ":test: Coverage"
        commands:
          - bash coverage.sh
        artifact_paths:
          - coverage/*
    ```

To get more familiar with Buildkite [pipelines](https://buildkite.com/docs/pipelines), [artifacts](https://buildkite.com/docs/pipelines/artifacts), etc. please consider to read [documentation](https://buildkite.com/docs/tutorials/getting-started).

## Create API Access Token
The authorization is required to communicate with Buildkite API. Buildkite provides an ability to [manage](https://buildkite.com/docs/apis/managing-api-tokens) API Access Tokens and their scopes within the organization and [user settings](https://buildkite.com/user/api-access-tokens). The following steps may be used to create a new Access Token:
1. Navigate to [user personal settings](https://buildkite.com/user/settings) and click on the [API Access Token tab](https://buildkite.com/user/api-access-tokens).
2. Press the **New API Access Token** button to create a new token.
3. On a token creating form set the Organization Access and desired **REST API Scopes** (for example, importing artifacts requires `read_builds` and `read_artifacts` scopes).
4. Finish token creation by pressing the **Create New API Access Token** button at the bottom of the page.
5. Confirm your password and copy token created, as it won't be visible again.
6. Use a new token in requests by setting `Authorization: Bearer <access token>` header.

## Retrieve artifacts via API
The `organization_slug` is required when using the endpoints below. It identifies the organization in the URL and the Buildkite API. The organization's slug can be obtained using one of the following ways:
1. **Using URL**. Open the [Buildkite](https://buildkite.com/) and select the organization from the dropdown menu at the left of the navigation bar. The URL will contain the slug of selected organization - `https://buildkite.com/{organization_slug}`.
2. **Using Buildkite API**. **GET** `/organizations` responses with a list of organizations accessible for the user. Each organization object contains the `slug` field you can use in endpoints below. 
   ```text
   {
     "id": "{organization_id}",
     "url": "{organization_api_url}",
     // ...
     "slug": "{organization_slug}",
     // ...
   }
   ```

There are several ways to retrieve artifacts using Buildkite API.
- **GET** `/organizations/{organization_slug}/builds` responses with a list of builds for the organization specified by `organization_slug`. Each build contains a list of jobs (i.e. Step execution) and each job contains a URL you can use to retrieve its artifacts.
    ```text
    {
      "id": "build_id",
      // ...
      "jobs": [
        {
          "id": "job_id",
          // ...
          "artifacts_url": "https://.../organizations/{organization_slug}/pipelines/{pipeline_slug}/builds/{build_number}/jobs/{job_id}/artifacts"
        }
      ] 
    }
    ```
- **GET** `/organizations/{organization_slug}/pipelines/{pipeline_slug}/builds` responses with a list of builds for the pipeline specified by `pipeline_slug`. This endpoint acts like the above one but is more specific.
- **GET** `/organizations/{organization_slug}/pipelines/{pipeline_slug}/builds/{build_number}/artifacts` responses with a list of artifacts generated by all jobs of a build specified by `build_number`. Each artifact contains the `download_url` field which you can use to download artifact.
    ```text
    {
      "id": "artifact_id",
      // ...
      "download_url": "https://.../organizations/{organization_slug}/pipelines/{pipeline_slug}/builds/{build_number}/jobs/{job_id}/artifacts/{artifact_id}/download"
    }
    ```
- **GET** `/organizations/{organization_slug}/pipelines/{pipeline_slug}/builds/{build_number}/jobs/{job_id}/artifacts` responses with a list of artifacts generated by job specified by `job_id`. Artifact object structure is the same as in the above endpoint.
- **GET** `/organizations/{organization_slug}/pipelines/{pipeline_slug}/builds/{build_number}/jobs/{job_id}/artifacts/{id}/download` responses with an artifact specified by `id`. This endpoint stands for the download URL of artifact.

More information in accessing artifacts you can find in [Artifacts API documentation](https://buildkite.com/docs/apis/rest-api/artifacts). Bitrise API [documentation](https://buildkite.com/docs/apis).

# CircleCI

## Deploy artifacts
CircleCI build job can be configured to store generated artifacts as follows:
1. In `.circleci/config.yml` go to a job you want to configure artifacts uploading for.
2. Add the `store_artifacts` attribute to the `steps` section of the job. There are no limitations in a number of `store_artifacts` steps within one job.
3. In `store_artifacts` specify the `path` with a path to directory/file you want to deploy (see an example of such file below).

```yaml
version: 2.1
workflows:
  main:
    jobs:
      - build
jobs:
  build:
    machine:
      image: ubuntu-1604:201903-01
    steps:
      - checkout
      - run:
          name: Creating Code Coverage Artifact
          command: bash coverage.sh
      - run:
          name: Check codecove
          command: ls
      - store_artifacts:
          path: coverage/
```

More information in artifacts storing can be found [here](https://circleci.com/docs/2.0/artifacts/). To get more familiar with CircleCI follow this [link](https://circleci.com/docs/2.0/about-circleci/#section=welcome).

## Create API Access Token
Some CircleCI endpoints require authorization to communicate with them. CircleCI provides an ability to create a Personal API Token that allows acting through API with no limitations. The following steps may be used to create a new token:
1. Navigate to [Personal API Tokens tab](https://account.circleci.com/tokens) under [User Settings page](https://account.circleci.com/settings/user).
2. Press the **Create New Token** button and type a token name in the popup.
3. Proceed by pressing **Add API Token** and copy a new token (make sure to take a copy of the generated token before moving to the next step as it won't be visible again).
4. Use the token in requests by using either a Basic Auth with **Authorization** header, **Circle-Token** header or another way provided in CircleCI API ([v1.1](https://circleci.com/docs/api/#get-authenticated), [v2](https://circleci.com/docs/api/v2/#authentication)).

## Retrieve artifacts via API
Here are endpoints that CircleCI provides to work with builds and artifacts:
- **GET** `/api/v1.1/project/{project_slug}` responses with a list of builds for the project specified by a `project_slug`. Each build has a build number (the `build_num` field) and contains a flag that states whether this build has artifacts or not (the `has_artifacts` field).
  ```text
  {
    // ...
    "build_num": <integer>,
    "has_artifacts": <boolean>,
    // ...
  }
  ```
- **GET** `api/v1.1/project/{project_slug}/{build_number}/artifacts` responses with a list of artifacts generated during a build specified by a `build_number`. Each artifact has the `url` field that contains a download URL for the artifact.
  ```text
  {
    // ...
    "path": "coverage/coverage.json",
    "url": "https://.../coverage/coverage.json"
  }
  ```

More information about the `project_slug` parameter can be found [here](https://circleci.com/docs/2.0/api-developers-guide/#getting-started-with-the-api). CircleCI API v1.1 (current stable version) [Summary](https://circleci.com/docs/api/#summary-of-api-endpoints) and [Overview](https://circleci.com/docs/api/#api-overview).

# Jenkins

## Deploy artifacts
Jenkins build job can be configured to store generated artifacts as follows:
1. In `Jenkinsfile` go to a stage you want to configure artifacts uploading for.
2. Add the `post` section to the stage.
3. Add `archiveArtifacts` step to the created `post` section with path to file or path pattern (see example below).

```text
pipeline {
    agent any
    stages {
        stage('Build') {
            steps {
                sh 'bash coverage.sh'
            }
            post {
                always {
                    archiveArtifacts 'coverage/*'
                }
            }
        }
    }
}
```

For more information in storing artifacts follow Jenkins [documentation](https://jenkins.io/doc/) and this [tour](https://jenkins.io/doc/pipeline/tour/tests-and-artifacts/).

## Create API Access Token
To access Jenkins's endpoints the authorization is required. You can use your username and password you've registered within an HTTP Basic Auth. For example:
1. Base64 encode username and password string as `username:password`.
2. Pass the result to `Authorization` header as `Authorization: Basic <token>`.

## Retrieve artifacts via API
The endpoints below contain the concept of `job`. Simply put, a job in Jenkins stands for a build workflow or pipeline. However, there can be jobs within other jobs (and even they can be within other jobs) so what does it mean? First, let us notice that URL for each sub-job recursively repeats - for example, `{lenkins_url}/job/{job}/job/{subjob}/job/{subsubjob}`. Consider the following: the very last job is a building pipeline itself; the job at the higher level is a list of build jobs configured; finally, the job at the highest level is a list of jobs with specific configurations for lists of build jobs they contain. Generally speaking, it depends on your Jenkins configurations for a project or projects. Here are some examples:
1. Creating a `Pipeline` in Jenkins (`New Item > Pipeline`) with the name `example-pipeline`. In this case, the created pipeline is a building pipeline and accessible through `{lenkins_url}/job/example-pipeline`. 
2. Creating a `Multibranch Pipeline` in Jenkins (`New Item > Multibranch Pipeline`) with the  name `example-pipeline`. In this case, the created pipeline will contain the list of building pipelines for each repository's branch matching configurations. For example, building pipeline for the `master` branch is accessible through `{lenkins_url}/job/example-pipeline/job/master`.
3. Creating a `GitHub Organization` in Jenkins (`New Item > GitHub Organization`) with the name `example-organization`. In this case, the created pipeline will contain the list of multibranch pipelines, and each multibranch pipeline has a list of building pipelines. For example, building pipeline for the `master` branch of the `example-project` repository is accessible through `{lenkins_url}/job/example-organization/job/example-project/job/master`.

Here are Jenkins' endpoints to work with builds and artifacts:
- **GET** `{jenkins_url}/api/json` responses with a master node of Jenkins that contains common information and list of pipelines configured.
  ```text
  {
    // ...
    "jobs": [
      {
        "name": <string>,
        // ...
      },
      // ...
    ]
  }
  ```
  Alternatively, you can request **GET** `{jenkins_url}/api/json?tree=jobs[name]` to fetch only list of pipelines configured.
  ```text
  {
    "jobs": [
      {
        "name": <string>
      },
      // ...
    ]
  }
  ```
  Select desired `job` and proceed to next endpoints using its `name` field.
- **GET** `{jenkins_url}/job/{job_name}/api/json` responses with a pipeline common information that contains a list of sub-pipelines configured.
  ```text
  {
    // ...
    "name": "{job_name}",
    "jobs": [
      {
        "name": <string>,
        // ...
      },
      // ...
    ]
  }
  ```
  Alternatively, you can request **GET** `{jenkins_url}/job/{job_name}/api/json?tree=jobs[name]` to fetch only list of pipelines configured within specified one. Use the `name` of desired `job` and proceed to retrieving builds data (in case if selected pipeline is a building one).
- **GET** `{jenkins_url}/job/{job_name}/job/{subjob_name}/api/json` responses with a pipeline common information that contains useful data about builds (first build, last build, last failed build, etc.) and a list of builds.
  ```text
  {
    // ...
    "fullName": "{job_name}/{subjob_name}",
    "name": "{subjob_name}",
    "builds": [
      {
        "number": <integer>,
        // ...
      },
      // ...
    ]
  }
  ```
  Same to previous endpoints, you can request **GET** `{jenkins_url}/job/{job_name}/job/{subjob_name}/api/json?tree=builds[number]` to fetch only list of builds with numbers.
- **GET** `{jenkins_url}/job/{job_name}/job/{subjob_name}/{build_number}/api/json` responses with a build specified by the `build_number` parameter. It also contains a list of artifacts generated during the build.
  ```text
  {
    // ...
    "number": build_number,
    "artifacts": [
      {
        "displayPath": <string>,
        "fileName": <string>,
        "relativePath": <string>
      },
      // ...
    ]
  }
  ```
  You can request **GET** `{jenkins_url}/job/{job_name}/job/{subjob_name}/{build_number}/api/json?tree=artifacts[displayPath,fileName,relativePath]` to fetch only artifacts list for a build.
- **GET** `{jenkins_url}/job/{job_name}/job/{subjob_name}/{build_number}/artifact/{relativePath}` responses with artifact found by `relativePath`. For example **GET** `{jenkins_url}/job/Test/job/master/5/artifact/coverage/coverage.json`

Using the `tree` query parameter for Jenkins API we can define properties of responses within different depth level. For example, fetch all builds with their artifacts for a pipeline: 
```text
GET {jenkins_url}/job/{job_name}/job/{subjob_name}/api/json?tree=name,fullName,builds[number,result,artifacts[displayPath,fileName,relativePath]]
```
The same possible with the `depth` query parameter but responses with fat JSON. For example, **GET** `{jenkins_url}/job/{job_name}/job/{subjob_name}/api/json?depth=1` responses with all information we've requested in the `tree` parameter above but the response size in more than 3 times larger.

More information in Jenkins API can be found [here](https://wiki.jenkins.io/display/JENKINS/Remote+access+API).

# Dependencies
> What is the project blocked on?

No blockers.

> What will be impacted by the project?

Importing/exporting code coverage metric approaches are impacted.

# Testing
> How will the project be tested?

Testing implementations related to importing coverage artifacts is a testing third-party API interactions and thus requires Third-party API testing approaches described [here](03_third_party_api_testing.md).

# Alternatives Considered
> Summarize alternative designs (pros & cons)

* Creating a separate CLI application for importing code coverage artifacts.
    - Pros:
        - No need for additional CI configurations.
        - The coverage importing process is not impacted by the CI API server.
    - Cons:
        - Complicates maintenance process.

# Timeline
> Document milestones and deadlines.

DONE:

  - Document importing code coverage artifact for all supported CI tools.
  - Document API interactions for importing coverage artifacts.
  
# Results
> What was the outcome of the project?

Work in progress.
